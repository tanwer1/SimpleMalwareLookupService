# Simple Malware Lookup Service

## Table of Contents

1. Problem Statement
   - The top level objective.
2. Objectives to be met/ SLA
3. General approach to the problem
4. System Interface
5. Load calculations
6. Data models
7. Simple design
8. Bottlenecks and suggestion
9. Security aspect
10. Telemetry and monitoring
11. Implementation approach

### Problem statement:
Malware URL lookup service

We have an HTTP proxy that is scanning traffic, looking for malware URLs. Before allowing HTTP connections to be made, this proxy asks a service that maintains several databases of malware URLs if the resource being requested is known to contain malware.

Write a small web service, preferably in Go or Python, that responds to GET requests where the caller passes in a URL and the service responds with some information about that URL. The GET requests would look like this:

GET /v1/urlinfo/{resource_url_with_query_string}

The caller wants to know if it is safe to access that URL or not. As the implementer, you get to choose the authorization, response format and structure. Please document the API in the README. These lookups are blocking users from accessing the URL until the caller receives a response from your service.

Give some thought to the following. Write-up the design, if you do not have time to code.

The size of the URL list could grow infinitely, how might you scale this beyond the memory capacity of the system? Bonus if you implement this.
The number of requests may exceed the capacity of this system, how might you solve that? Bonus if you implement this.
What are some strategies you might use to update the service with new URLs? Updates may be as many as 5000 URLs a day with updates arriving every 10 minutes.


### Objectives to be met/ SLA:
The service sits as a helper service the http proxy, http proxy should be fast and user should not notice the delay or service failures.

Functional requirement: 
1. Get method to check if the resource url is a safe url or not.
2. Add/remove a bad url to the system.

Non-fucntional requirements: 
1. The response of the URL lookup service should be fast (say response time of : 100 ms).
2. The service is up 999.99 percent of the time.


### General approach to the problem:

As a simple approach for this malware lookup service is to have a server which accepts the requests, looks up in its data store and returns information indicating whether safe or unsafe.
Also one should be able to call endpoint to update/remove the db with the new url info.

Client comes to check the validity of url.

AdminClient comes with the add/remove a url or a set of url.

### System Interface:
The Syetem APIs exposed are as:
1. urlInfo(userInfo, resource_url_with_query_string)  returns a json e.g: {"status": 200, "isSafe": True}. 
   userInfo: username/passwd information.
   resource_url_with_query_string : the url query strings safety to be checked.
2. addUrl(adminUser, resource_url) returns a json e.g: {"status": 200 }

Desirable:
3. removeUrl(adminUser, resource_url) returns a json e.g: {"status": 200 } [Not implementing this for this exercise]


### Load calculations:
We are given the load to add new urls to be coming at a rate of 5000 urls/day ==> 35 requests / 10 min.
As the update requests are coming at a regular cadence every 10 min, we have a peak every 10 min for 35 requests.

*Storage need*

Also the db is ever growing, with a rate of 5000 urls /day. we expect the load in 5 yrs to be:

5 K * 365 * 5 = 9125 K entries in db for urls.

assuming average url takes about 100 characters ==> 9.125 million * 100 char = * 900.125 million bytes < 1 GB * 


Assuming a url check load of 100 times than the update load.

500 x 1000 urls/day = 5 requests/sec


### Data models:

In the simple service, the database needs to store only a table:

   |-----------|
   | UnsafeUrl |
   |-----------|


## Simple design:

The simple design is, there is a frontend which receives the request, checks the auth/permission of the user (with some auth service and permission service), given the work to be done by the worker serivce. The worker service queries the db and returns the result.
The backend-fornt and the worker can talk with a queue.
similarly for the add/update, we have the same mechanism, the work updates the db here instead of querying.

               backend-server -----> workers (multiple) ----> db


### Bottlenecks and suggestion/ future enhancements:
1. In our design the same backend-server is used to both add a new url and query for a given url is used, they can be split into different microservices.

2. if the service becomes more popular, we need to implement multiple servers to reduce load per server. The servers can be behind a load balancer and there is further scope to scale the service by having mutliple load balancers (load balancing using DNS ).

3. As this is an ever increasing number of Unsafe Urls in the system, the db size can grow forever. A good approach will be to implement the db in a Distributed hash table format (shards of db in a logical ring, a shard only contains a subset of information, when we one of the server is achieving a limit another server can be inserted in the ring and adjusting the hash calculations).

4. Put a more scalable queue between backend-server and worker.

5. As the system has to be high performing, a possible use of the cache can be considered.

6. The service can be made multi-tenant, this brings new challenges that some of the urls may be unsafe of one tenant, whereas they are not unsafe for another tenant.

### Security aspect:
1. Assuming the service is sitting in public cloud domain, the first line of security needs to be at the firewall level stating which all ips are allowed to communicate to this service from outside.
2. All the internal microservices can be on a virtual network private to the microservices (allowing no outside entity to be able to interact with those services).
3. The service can be behind https instead of http.
4. all users need to authenticated with an identity service.
5. If a user is coming too often (exceeding some quota), the user needs to be throttled.
6. More thoughts need to be put on handling denial of service attacks (distributed denial of service attack is a real threat to this service).

### Telemetry and monitoring:
1. If the service is a offered as a SaaS service, for the purpose of billing need to monitor the request conunt coming and bill accordingly.
2. Monitor all the microservices and health of those services, self correct/alert on the services.
3. logging is an important aspect and should be pushed to some location (more actionable things can be done here with log to metric etc).
4. Its important to monitor the time taken for the services to respond, also the SLA promise can be monitored here.
5. The usage pattern can also be understood by generating the appropriate data with monitoring and logging and analyzing those.

## Implementation approach:
1. Assume only ASCII char in the urls, not considering utf-8 and other char sets.
2. A simple service is to implemented, the approach and technology used as are as follows:
   a. Using the celery worker with flask framework, this gives the flexibility the server is a single server but the workers can be many (scale as need), keeping the flask server free to get new requests.
   b. For communication between flask and celery the queue used is in redis.
   c. Use redis for keeping the badurls data.
   
   
   
          backend-server ----> queue(redis)---> worker-1.     <--------> db (redis)  
                                     |--------> worker-2      <---------->|
                                     |            :                       |
                                     |--------> worker-n      <---------->|

